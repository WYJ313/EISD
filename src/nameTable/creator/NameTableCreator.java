package nameTable.creator;

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;

import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.AbstractTypeDeclaration;
import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
import org.eclipse.jdt.core.dom.Block;
import org.eclipse.jdt.core.dom.BodyDeclaration;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.EnumConstantDeclaration;
import org.eclipse.jdt.core.dom.EnumDeclaration;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.FieldDeclaration;
import org.eclipse.jdt.core.dom.ImportDeclaration;
import org.eclipse.jdt.core.dom.Initializer;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.PackageDeclaration;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
import org.eclipse.jdt.core.dom.Statement;
import org.eclipse.jdt.core.dom.Type;
import org.eclipse.jdt.core.dom.TypeDeclaration;
import org.eclipse.jdt.core.dom.TypeParameter;
import org.eclipse.jdt.core.dom.VariableDeclaration;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;

import sourceCodeAST.CompilationUnitRecorder;
import sourceCodeAST.SourceCodeFile;
import sourceCodeAST.SourceCodeFileSet;
import sourceCodeAST.SourceCodeLocation;
import nameTable.NameTableManager;
import nameTable.nameDefinition.AnonymousClassDefinition;
import nameTable.nameDefinition.AutoGeneratedConstructor;
import nameTable.nameDefinition.DetailedTypeDefinition;
import nameTable.nameDefinition.EnumConstantDefinition;
import nameTable.nameDefinition.EnumTypeDefinition;
import nameTable.nameDefinition.FieldDefinition;
import nameTable.nameDefinition.MethodDefinition;
import nameTable.nameDefinition.NameDefinitionKind;
import nameTable.nameDefinition.PackageDefinition;
import nameTable.nameDefinition.TypeParameterDefinition;
import nameTable.nameDefinition.VariableDefinition;
import nameTable.nameReference.NameReference;
import nameTable.nameReference.NameReferenceLabel;
import nameTable.nameReference.PackageReference;
import nameTable.nameReference.ParameterizedTypeReference;
import nameTable.nameReference.QualifiedTypeReference;
import nameTable.nameReference.TypeReference;
import nameTable.nameScope.CompilationUnitScope;
import nameTable.nameScope.LocalScope;
import nameTable.nameScope.NameScope;
import nameTable.nameScope.NameScopeKind;
import nameTable.nameScope.SystemScope;

/**
 * Create all name definitions and name references of all Java source code files under a system path
 * @author Zhou Xiaocong
 * @since 2013-2-21
 * @version 1.0
 * 
 * @update 2013-12-28 Zhou Xiaocong
 *   Use the class SourceCodeParser to parse all source files in a given path, and then modify the the constructor (i.e. NameTableCreator(String)) to
 *   create a SourceCodeParser for this.parser,, and modify the method create() to use this.parser to parse the source files in the path.   
 *   Moreover, add a constructor(i.e. NameTableCreator(SourceCodeParser)) to allow the client provide a SourceCodeParser to parse the source files, and
 *   delete the method loadFile(), parseSourceCode() and getAllJavaSourceFiles(), since their functions had been implemented in the class SourceCodeParser.
 *   
 * @update 2016/11/11
 * 		Refactor the class according to the design document
 */
public class NameTableCreator {
	protected SourceCodeFileSet codeFileSet = null;
	List<CompilationUnitRecorder> errorUnitList = null;
	
	protected TypeASTVisitor typeVisitor = null;
	protected ExpressionASTVisitor expressionVisitor = null;

	public NameTableCreator(SourceCodeFileSet codeFileSet) {
		this.codeFileSet = codeFileSet;
		errorUnitList = new ArrayList<CompilationUnitRecorder>();
		
		expressionVisitor = new ExpressionASTVisitor(this, null, null, true);
		typeVisitor = new TypeASTVisitor(null, null);
	}
	
	/**
	 * Create all name definitions and name reference in name table, read informations about imported types from the given file list and bind 
	 * imports in all compilation units, and define all global name. i.e. the returned name table manager is ready for resolving name reference! 
	 * The print writer is used to display the process information.
	 */
	public NameTableManager createNameTableManager(PrintWriter reporter, String[] externalFileNameArray) {
		SystemScope systemScope = create(reporter);
		NameTableManager table = new NameTableManager(codeFileSet, systemScope);
		ImportedTypeManager.readImportedTypesFromExternalFiles(table, externalFileNameArray);
		ImportedTypeManager.bindImportsInAllCompilationUnits(table);
		ImportedTypeManager.defineGlobalNames(table);
		
		return table;
	}
	
	/**
	 * Create all name definitions and name reference in name table, read informations about imported types from the given file list and bind 
	 * imports in all compilation units, and define all global name. i.e. the returned name table manager is ready for resolving name reference! 
	 * The print writer is used to display the process information.
	 */
	public NameTableManager createNameTableManager(String[] externalFileNameArray) {
		SystemScope systemScope = create(null);
		NameTableManager table = new NameTableManager(codeFileSet, systemScope);
		ImportedTypeManager.readImportedTypesFromExternalFiles(table, externalFileNameArray);
		ImportedTypeManager.bindImportsInAllCompilationUnits(table);
		ImportedTypeManager.defineGlobalNames(table);
		
		return table;
	}
	
	/**
	 * Create all name definitions and name reference in name table, and bind imports in all compilation units, and define all global name.
	 * i.e. the returned name table manager is ready for resolving name reference! The print writer is used to display the process information.
	 * 
	 */
	public NameTableManager createNameTableManager(PrintWriter reporter) {
		SystemScope systemScope = create(reporter);
		NameTableManager table = new NameTableManager(codeFileSet, systemScope);
		ImportedTypeManager.bindImportsInAllCompilationUnits(table);
		ImportedTypeManager.defineGlobalNames(table);
		
		return table;
	}
	
	/**
	 * Create all name definitions and name reference in name table, and bind imports in all compilation units, and define all global name.
	 * i.e. the returned name table manager is ready for resolving name reference! 
	 */
	public NameTableManager createNameTableManager() {
		SystemScope systemScope = create(null);
		NameTableManager table = new NameTableManager(codeFileSet, systemScope);
		ImportedTypeManager.bindImportsInAllCompilationUnits(table);
		ImportedTypeManager.defineGlobalNames(table);
		
		return table;
	}
	
	/**
	 * Test if there are any errors when creating the name table of the given source code file set.
	 */
	public boolean hasError() {
		if (errorUnitList == null) return false;
		if (errorUnitList.size() <= 0) return false;
		return true;
	}
	
	/**
	 * Return the number of compilation unit which has error when creating the name table. 
	 */
	public int getErrorUnitNumber() {
		if (errorUnitList == null) return 0;
		return errorUnitList.size();
	}
	
	/**
	 * Return the list of compilation unit which has error when creating the name table. 
	 */
	public List<CompilationUnitRecorder> getErrorUnitList() {
		return errorUnitList;
	}
	
	/**
	 * Print the list of compilation unit which has error when creating the name table to the given writer. 
	 */
	public void printErrorUnitList(PrintWriter writer) {
		if (errorUnitList == null) return;
		
		writer.println("Unit\tError Message");
		for (CompilationUnitRecorder errorUnit : errorUnitList) {
			writer.println(errorUnit.unitName + "\t" + errorUnit.getErrorMessage());
		}
	}
	
	/**
	 * Create all name definitions and name references of all Java source code files under the given path
	 */
	SystemScope create(PrintWriter reporter) {
		SystemScope systemScope = new SystemScope();
		
		for (SourceCodeFile codeFile : codeFileSet) {
			String unitName = codeFileSet.getFileUnitName(codeFile);
			if (reporter != null) reporter.println("Scan file: " + unitName);
			
			if (codeFile.hasCreatedAST()) {
				CompilationUnit root = codeFile.getASTRoot();
				CompilationUnitRecorder currentUnitFile = new CompilationUnitRecorder(unitName, root);

				int rootLength = root.getLength();
				int typeNumber = 0;
				// 2017/2/17: (rootLength <= 0) implies this file has no character. 
				if (rootLength > 0) typeNumber = scanCurrentCompilationUnit(currentUnitFile, systemScope);
				if (typeNumber <= 0) {
					String errorMessage = "NoScanedType : there is no class, interface or enumeration!";
					currentUnitFile.setErrorMessage(errorMessage);
					errorUnitList.add(currentUnitFile);
					if (reporter != null) reporter.println("\tThere is no class, interface or enumeration types in file!");
				}
				codeFile.releaseAST();
				codeFile.releaseFileContent();
			} else {
				String parsingErrorMessage = codeFile.getParsingErrorMessage();
				String errorMessage = "ParseringError : " + parsingErrorMessage;
				CompilationUnitRecorder unitFile = new CompilationUnitRecorder(unitName, null);
				unitFile.setErrorMessage(errorMessage);
				errorUnitList.add(unitFile);

				if (reporter != null) reporter.println("\tError message: " + codeFile.getParsingErrorMessage());
			}
			
		}
		return systemScope;
	}

	
	/**
	 * Scan current compilation unit to create name definitions and references
	 * CompilationUnit:
     *   [ PackageDeclaration ]
     *     { ImportDeclaration }
     *     { TypeDeclaration | EnumDeclaration | AnnotationTypeDeclaration | ; }
     * @pre-condition: currentSourceFileName ! = null &&  currentASTRoot != null
	 */
	int scanCurrentCompilationUnit(CompilationUnitRecorder currentUnitFile, SystemScope currentScope) {
		int scanedTypeNumber = 0;
		CompilationUnit node = currentUnitFile.root; 
		// 1. Process the package declaration in the unit
		PackageDeclaration packageDecl = node.getPackage();
		PackageDefinition packageDef = null;
		String packageName = null;
		if (packageDecl != null) {
			packageName = packageDecl.getName().getFullyQualifiedName();
			packageDef = currentScope.findPackageByName(packageName);
		} else {
			// The unit is in the unnamed package
			packageDef = currentScope.getUnnamedPackageDefinition();
		}
		if (packageDef == null) {
			// The package definition has not been add in the current scope!
			if (packageDecl != null) packageDef = new PackageDefinition(packageName, currentScope);
			else packageDef = new PackageDefinition(currentScope);
			// Define the package to the current scope
			currentScope.define(packageDef);
		}
		
		// 2 Create a compilation unit scope in the package
		SourceCodeLocation start = SourceCodeLocation.getStartLocation(node, currentUnitFile.root, currentUnitFile.unitName);
		SourceCodeLocation end = SourceCodeLocation.getEndLocation(node, currentUnitFile.root, currentUnitFile.unitName);
		CompilationUnitScope unitScope = new CompilationUnitScope(currentUnitFile.unitName, packageDef, start, end);
		packageDef.addCompilationUnitScope(unitScope);
		
		// 3 Process the import declarations in the node
		@SuppressWarnings("unchecked")
		List<ImportDeclaration> imports = node.imports();
		for (ImportDeclaration importDecl : imports) {
			// Scan an import declaration. So far we DO NOT treat a static import declaration!
			if (!importDecl.isStatic()) {
				if (importDecl.isOnDemand()) {
					// create package reference for on-demand-import declaration
					String name = importDecl.getName().getFullyQualifiedName();		// it will be name of a package!
					SourceCodeLocation location = SourceCodeLocation.getStartLocation(importDecl, currentUnitFile.root, currentUnitFile.unitName);
					PackageReference packageRef = new PackageReference(name, location, unitScope);
					unitScope.addImportedTypeReference(packageRef);
					
					// We do not add type reference or package reference to the reference list of the scope!
				} else {
					// create type reference for single-type-import declaration
					String name = importDecl.getName().getFullyQualifiedName();		// it will be name of a class!
					SourceCodeLocation location = SourceCodeLocation.getStartLocation(importDecl, currentUnitFile.root, currentUnitFile.unitName);
					TypeReference type = new TypeReference(name, location, unitScope);
					unitScope.addImportedTypeReference(type);
					
					// We do not add type reference or package reference to the reference list of the scope!
				}
			} else {
				if (importDecl.isOnDemand()) {
					// create type reference for on-demand-import static declaration
					String name = importDecl.getName().getFullyQualifiedName();		// it will be name of a package!
					SourceCodeLocation location = SourceCodeLocation.getStartLocation(importDecl, currentUnitFile.root, currentUnitFile.unitName);
					TypeReference typeRef = new TypeReference(name, location, unitScope);
					unitScope.addImportedStaticMemberReference(typeRef);
					
					// We do not add type reference or name reference to the reference list of the scope!
				} else {
					// create name reference for single-type-import static declaration
					String name = importDecl.getName().getFullyQualifiedName();		// it will be name of a class!
					SourceCodeLocation location = SourceCodeLocation.getStartLocation(importDecl, currentUnitFile.root, currentUnitFile.unitName);
					NameReference member = new NameReference(name, location, unitScope);
					unitScope.addImportedStaticMemberReference(member);
					
					// We do not add type reference or name reference to the reference list of the scope!
				}
			}
		}
		
		// 4 Process the list declarations in the node
		@SuppressWarnings("unchecked")
		List<AbstractTypeDeclaration> types = node.types();
		
		for (AbstractTypeDeclaration type : types) {
			if (type.getNodeType() == ASTNode.TYPE_DECLARATION) {
				scan(currentUnitFile, packageName, (TypeDeclaration)type, unitScope);
				scanedTypeNumber++;
			} else if (type.getNodeType() == ASTNode.ENUM_DECLARATION) {
				scan(currentUnitFile, packageName, (EnumDeclaration)type, unitScope);
				scanedTypeNumber++;
			}
		}
		return scanedTypeNumber;
	}

	
	/**
	 * Scan a type declaration node to create name definitions and references
     * TypeDeclaration:
     *  [ Javadoc ] { Modifier } class Identifier
     *                   [ extends Type]
     *                   [ implements Type { , Type } ]
     *                   { { BodyDeclaration | ; } }
     *  BodyDeclaration: FieldDelcaration MethodDeclaration TypeDeclaration           
	 */
	@SuppressWarnings("unchecked")
	void scan(CompilationUnitRecorder currentUnitFile, String qualifier, TypeDeclaration node, NameScope currentScope) {
		// Create a type definition for the node
		String name = node.getName().getFullyQualifiedName();
		String fullQualifiedName = (qualifier == null) ? name : qualifier + NameReferenceLabel.NAME_QUALIFIER + name;
		SourceCodeLocation location = SourceCodeLocation.getStartLocation(node, currentUnitFile.root, currentUnitFile.unitName);
		SourceCodeLocation endLocation = SourceCodeLocation.getEndLocation(node, currentUnitFile.root, currentUnitFile.unitName);
		DetailedTypeDefinition typeDef = new DetailedTypeDefinition(name, fullQualifiedName, location, currentScope, endLocation);
		typeDef.setInterface(node.isInterface());
		typeDef.setPackageMember(node.isPackageMemberTypeDeclaration());
		typeDef.setModifierFlag(node.getModifiers());
		currentScope.define(typeDef);
		
		// Create type reference for the super class
		if (node.getSuperclassType() != null) {
			Type superClassType = node.getSuperclassType();
			typeVisitor.reset(currentUnitFile, currentScope);
			superClassType.accept(typeVisitor);
			TypeReference superClassRef = typeVisitor.getResult();
			typeDef.addSuperType(superClassRef);
			// Add to the reference list in the current scope, which include the type definition
			currentScope.addReference(superClassRef);
		}
		// Create type reference for the super interfaces
		List<Type> superInterfaces = node.superInterfaceTypes();
		for (Type superInterface : superInterfaces) {
			typeVisitor.reset(currentUnitFile, currentScope);
			superInterface.accept(typeVisitor);
			TypeReference superInterfaceRef = typeVisitor.getResult();
			typeDef.addSuperType(superInterfaceRef);
			// Add to the reference list in the current scope, which include the type definition
			currentScope.addReference(superInterfaceRef);
		}
		
		// Process the type parameter definition of the node
		List<TypeParameter> typeParameterList = node.typeParameters();
		for (TypeParameter typeParameter : typeParameterList) {
			String typeParaName = typeParameter.getName().getFullyQualifiedName();
			SourceCodeLocation typeParaLocation = SourceCodeLocation.getStartLocation(typeParameter, currentUnitFile.root, currentUnitFile.unitName);
			TypeParameterDefinition typeParaDef = new TypeParameterDefinition(typeParaName, typeParaName, typeParaLocation, typeDef);
			typeDef.define(typeParaDef);
		}
		
		// Process the initializers in the node
		List<BodyDeclaration> bodyList = node.bodyDeclarations();
		for (BodyDeclaration bodyDecl : bodyList) {
			int nodeType = bodyDecl.getNodeType();
			if (nodeType == ASTNode.INITIALIZER) {
				scan(currentUnitFile, (Initializer)bodyDecl, typeDef);
			}
		}
	
		// Process the field declarations in the node
		FieldDeclaration[] fields = node.getFields();
		for (int index = 0; index < fields.length; index++) scan(currentUnitFile, fullQualifiedName, fields[index], typeDef);
		
		// Process the method declarations in the node
		MethodDeclaration[] methods = node.getMethods();
		for (int index = 0; index < methods.length; index++) scan(currentUnitFile, fullQualifiedName, methods[index], typeDef);
		
		// Automatically generated default constructor if this class has not any constructor
		boolean hasConstructor = false;
		List<MethodDefinition> methodList = typeDef.getMethodList();
		if (methodList != null) {
			for (MethodDefinition method : methodList) {
				if (method.isConstructor()) {
					hasConstructor = true;
					break;
				}
			}
		}
		if (!hasConstructor) {
			MethodDefinition defaultConstructor = new AutoGeneratedConstructor(name, fullQualifiedName, location, typeDef, location);
			typeDef.define(defaultConstructor);
		}
		
		// Process the type declarations in the node
		AbstractTypeDeclaration[] typeMembers = node.getTypes(); 
		for (int index = 0; index < typeMembers.length; index++) {
			AbstractTypeDeclaration type = typeMembers[index];
			if (type.getNodeType() == ASTNode.TYPE_DECLARATION) {
				scan(currentUnitFile, fullQualifiedName, (TypeDeclaration)type, typeDef);
			} else if (type.getNodeType() == ASTNode.ENUM_DECLARATION) {
				scan(currentUnitFile, fullQualifiedName, (EnumDeclaration)type, typeDef);
			}
		}
	}

	/**
	 * Scan the initializer block of the detailed type definition
	 */
	void scan(CompilationUnitRecorder currentUnitFile, Initializer node, DetailedTypeDefinition type) {
		Block body = node.getBody();
		if (body != null) {
			SourceCodeLocation start = SourceCodeLocation.getStartLocation(body, currentUnitFile.root, currentUnitFile.unitName);
			SourceCodeLocation end = SourceCodeLocation.getEndLocation(body, currentUnitFile.root, currentUnitFile.unitName);
			LocalScope localScope = createLocalScope(start, end, type);
			type.addInitializer(localScope);
			
			// We can not reuse the block visitor for all methods, because when the method defines 
			// local types, and there are methods in the local types, we can not reuse the scope stack in 
			// the same block visitor! 
			BlockASTVisitor blockVisitor = new BlockASTVisitor(this, currentUnitFile, localScope);
			// Then visit all children of the block
			@SuppressWarnings("unchecked")
			List<Statement> statementList = body.statements();
			for (Statement statement : statementList) statement.accept(blockVisitor);
		}
	}
	
	/**
	 * Scan a enum declaration node to create name definitions and references
	 * EnumDeclaration:
     * 	[ Javadoc ] { ExtendedModifier } enum Identifier
     *	    [ implements Type { , Type } ]
     *	    {
     *	    	[ EnumConstantDeclaration { , EnumConstantDeclaration } ] [ , ]
     *	    	[ ; { ClassBodyDeclaration | ; } ]
     *	    }
	 */
	@SuppressWarnings("unchecked")
	void scan(CompilationUnitRecorder currentUnitFile, String qualifier, EnumDeclaration node, NameScope currentScope) {
		// Create a type definition for the node
		String name = node.getName().getFullyQualifiedName();
		String fullQualifiedName = (qualifier == null) ? name : qualifier + NameReferenceLabel.NAME_QUALIFIER + name;
		SourceCodeLocation location = SourceCodeLocation.getStartLocation(node, currentUnitFile.root, currentUnitFile.unitName);
		SourceCodeLocation endLocation = SourceCodeLocation.getEndLocation(node, currentUnitFile.root, currentUnitFile.unitName);
		EnumTypeDefinition typeDef = new EnumTypeDefinition(name, fullQualifiedName, location, currentScope, endLocation);
		typeDef.setPackageMember(node.isPackageMemberTypeDeclaration());
		typeDef.setModifierFlag(node.getModifiers());
		currentScope.define(typeDef);
		
		// Create type reference for the super interfaces
		List<Type> superInterfaces = node.superInterfaceTypes();
		for (Type superInterface : superInterfaces) {
			typeVisitor.reset(currentUnitFile, currentScope);
			superInterface.accept(typeVisitor);
			TypeReference superInterfaceRef = typeVisitor.getResult();
			typeDef.addSuperType(superInterfaceRef);
			// Add to the reference list in the current scope, which include the type definition
			currentScope.addReference(superInterfaceRef);
		}
		
		// Process the constant declarations in the node. We regard the enum constant as method 
		List<EnumConstantDeclaration> constants = node.enumConstants();
		for (EnumConstantDeclaration constant : constants) {
			scan(currentUnitFile, fullQualifiedName, constant, typeDef);
		}
	}

	/**
	 * Scan a field declaration node to create name definitions and references
	 * FieldDelcaration: [Javadoc] { ExtendedModifier } Type VariableDeclarationFragment
     *                       { , VariableDeclarationFragment } ;
	 */
	@SuppressWarnings("unchecked")
	void scan(CompilationUnitRecorder currentUnitFile, String qualifier, FieldDeclaration node, NameScope currentScope) {
		// Get the type reference for the variable declaration
		Type type = node.getType();
		typeVisitor.reset(currentUnitFile, currentScope);
		type.accept(typeVisitor);
		TypeReference typeRef = typeVisitor.getResult();
		// Add to the reference list in the currentScope, which include the field
		currentScope.addReference(typeRef);
		
		int modifierFlag = node.getModifiers();
		
		// Visit the variable list defined in the node
		List<VariableDeclarationFragment> fragments = node.fragments();
		for (VariableDeclarationFragment varNode : fragments) {
			// Define the variable to the current scope
			FieldDefinition field = defineField(currentUnitFile, qualifier, varNode, typeRef, currentScope, modifierFlag);
			
			// Visit the initializer in the variable declaration
			Expression initializer = varNode.getInitializer();
			if (initializer != null) {
				expressionVisitor.reset(currentUnitFile, currentScope);
				initializer.accept(expressionVisitor);
				NameReference initExpRef = expressionVisitor.getResult();
				currentScope.addReference(initExpRef);
				field.setInitializer(initExpRef);
			}
		}
	}
	
	/**
	 * Scan a method declaration node to create name definitions and references
     *  [ Javadoc ] { ExtendedModifier }
     *              [ < TypeParameter { , TypeParameter } > ]
     *    ( Type | void ) Identifier (
     *    [ FormalParameter
     *                 { , FormalParameter } ] ) {[ ] }
     *   [ throws TypeName { , TypeName } ] ( Block | ; )
	 */
	@SuppressWarnings("unchecked")
	void scan(CompilationUnitRecorder currentUnitFile, String qualifier, MethodDeclaration node, NameScope currentScope) {
		// Create method definition for the node
		String methodName = node.getName().getFullyQualifiedName();
		String fullQualifiedName = (qualifier == null) ? methodName : qualifier + NameReferenceLabel.NAME_QUALIFIER + methodName;
		SourceCodeLocation location = SourceCodeLocation.getStartLocation(node, currentUnitFile.root, currentUnitFile.unitName);
		SourceCodeLocation endLocation = SourceCodeLocation.getEndLocation(node, currentUnitFile.root, currentUnitFile.unitName);
		MethodDefinition methodDef = new MethodDefinition(methodName, fullQualifiedName, location, currentScope, endLocation);

		// Create type reference for the return type
		Type returnType = node.getReturnType2();
		TypeReference returnTypeRef = null;
		if (returnType != null) {
			typeVisitor.reset(currentUnitFile, methodDef);
			returnType.accept(typeVisitor);
			returnTypeRef = typeVisitor.getResult();
			int dimension = returnTypeRef.getDimension() + node.getExtraDimensions();
			returnTypeRef.setDimension(dimension);
			
			// Add the reference to the reference list in the current scope, which include the method
			currentScope.addReference(returnTypeRef);
		} // else is a constructor 
		methodDef.setReturnType(returnTypeRef);
		methodDef.setModifierFlag(node.getModifiers());
		methodDef.setConstructor(node.isConstructor());
		currentScope.define(methodDef);

		// Process the type parameter definition of the node
		List<TypeParameter> typeParameterList = node.typeParameters();
		for (TypeParameter typeParameter : typeParameterList) {
			String typeParaName = typeParameter.getName().getFullyQualifiedName();
			SourceCodeLocation typeParaLocation = SourceCodeLocation.getStartLocation(typeParameter, currentUnitFile.root, currentUnitFile.unitName);
			TypeParameterDefinition typeParaDef = new TypeParameterDefinition(typeParaName, typeParaName, typeParaLocation, methodDef);
			methodDef.define(typeParaDef);
		}
		
		// Create parameter definition for the node
		List<SingleVariableDeclaration> parameters = node.parameters();
		for (SingleVariableDeclaration parameter : parameters) {
			defineParameber(currentUnitFile, parameter, methodDef);
		}
		
		// Create type reference for throws type in the node
		List<Type> throwTypes = node.thrownExceptionTypes();
		for (Type throwType : throwTypes) {
			typeVisitor.reset(currentUnitFile, currentScope);
			throwType.accept(typeVisitor);
			TypeReference throwTypeRef = typeVisitor.getResult();
			methodDef.addThrowType(throwTypeRef);

			// Add the reference to the reference list in the current scope, which include the method
			currentScope.addReference(returnTypeRef);
		}
		
		// Scan the body of the method
		Block body = node.getBody();
		if (body != null) {
			SourceCodeLocation start = SourceCodeLocation.getStartLocation(body, currentUnitFile.root, currentUnitFile.unitName);
			SourceCodeLocation end = SourceCodeLocation.getEndLocation(body, currentUnitFile.root, currentUnitFile.unitName);
			LocalScope localScope = createLocalScope(start, end, methodDef);
			methodDef.setBodyScope(localScope);
			// We can not reuse the block visitor for all methods, because when the method defines 
			// local types, and there are methods in the local types, we can not reuse the scope stack in 
			// the same block visitor! 
			BlockASTVisitor blockVisitor = new BlockASTVisitor(this, currentUnitFile, localScope);
			// Then visit all children of the block
			List<Statement> statementList = body.statements();
			for (Statement statement : statementList) statement.accept(blockVisitor);
		}
	}

	/**
	 * Scan an enum constant declaration node to create name definitions and references
	 */
	@SuppressWarnings("unchecked")
	void scan(CompilationUnitRecorder unitFile, String qualifier, EnumConstantDeclaration node, NameScope currentScope) {
		String name = node.getName().getFullyQualifiedName();
		String fullQualifiedName = (qualifier == null) ? name : qualifier + NameReferenceLabel.NAME_QUALIFIER + name;
		SourceCodeLocation location = SourceCodeLocation.getStartLocation(node, unitFile.root, unitFile.unitName);
		
		EnumConstantDefinition constDef = new EnumConstantDefinition(name, fullQualifiedName, location, currentScope);
		currentScope.define(constDef);
		
		List<Expression> arguments = node.arguments();
		for (Expression argument : arguments) {
			expressionVisitor.reset(unitFile, currentScope);
			argument.accept(expressionVisitor);
			NameReference argRef = expressionVisitor.getResult();
			if (argRef != null) {
				constDef.addArgument(argRef);
				// Add the reference to the reference list in the current scope, which include the enum constant
				currentScope.addReference(argRef);
			}
		}
	}
	
	
	/**
	 * Scan an anonymous class declaration node to create name definitions and references
     * AnonymousClassDeclaration:
     *                   { ClassBodyDeclaration }
     * @param superTypeReference: In general, anonymous class is a sub-class of a interface or class.
	 */
	@SuppressWarnings("unchecked")
	void scan(CompilationUnitRecorder currentUnitFile, String qualifier, AnonymousClassDeclaration node, NameScope currentScope, TypeReference superTypeReference) {
		// Create a type definition for the node
		SourceCodeLocation location = SourceCodeLocation.getStartLocation(node, currentUnitFile.root, currentUnitFile.unitName);
		SourceCodeLocation endLocation = SourceCodeLocation.getEndLocation(node, currentUnitFile.root, currentUnitFile.unitName);
		String name = AnonymousClassDefinition.getAnonymousClassSimpleName(location);
		String fullQualifiedName = (qualifier == null) ? name : qualifier + NameReferenceLabel.NAME_QUALIFIER + name;
		AnonymousClassDefinition typeDef = new AnonymousClassDefinition(name, fullQualifiedName, location, currentScope, endLocation);
		currentScope.define(typeDef);
		
		if (superTypeReference != null) typeDef.addSuperType(superTypeReference);
		
		List<BodyDeclaration> bodyList = node.bodyDeclarations();
		for (BodyDeclaration bodyDecl : bodyList) {
			int nodeType = bodyDecl.getNodeType();
			if (nodeType == ASTNode.INITIALIZER) {
				scan(currentUnitFile, (Initializer)bodyDecl, typeDef);
			} else if (nodeType == ASTNode.FIELD_DECLARATION) {
				scan(currentUnitFile, fullQualifiedName, (FieldDeclaration)bodyDecl, typeDef);
			} else if (nodeType == ASTNode.METHOD_DECLARATION) {
				scan(currentUnitFile, fullQualifiedName, (MethodDeclaration)bodyDecl, typeDef);
			} else if (nodeType == ASTNode.TYPE_DECLARATION) {
				scan(currentUnitFile, fullQualifiedName, (TypeDeclaration)bodyDecl, typeDef);
			} else {
				throw new AssertionError("Incorrect AST node type in anonymous class at " + location.getUniqueId());
			}
		}
	}
	
	/**
	 * Check whether a local scope is need to create for the block in the current compilation unit.
	 */
	@SuppressWarnings("unchecked")
	boolean needCreateLocalScope(Block block) {
		boolean createLocalScope = false;
		List<Statement> statementList = block.statements();
		for (Statement statement : statementList) {
			int nodeType = statement.getNodeType();
			if (nodeType == ASTNode.TYPE_DECLARATION_STATEMENT || nodeType == ASTNode.VARIABLE_DECLARATION_STATEMENT) {
				createLocalScope = true;
				break;
			}
		}
		return createLocalScope;
	}
	
	/**
	 * Create a local scope for source codes from start location to the end location in the current compilation unit. The parent scope of 
	 * the new local scope is parent. 
	 * This method maintain the parent (i.e. enclosing) scope of the new scope, and the sub-scope list of the parent
	 * @return The new scope created by the method
	 */
	LocalScope createLocalScope(SourceCodeLocation start, SourceCodeLocation end, NameScope parent) {
		LocalScope localScope = new LocalScope(parent, start, end);
		if (parent.getScopeKind() == NameScopeKind.NSK_LOCAL) {
			LocalScope currScope = (LocalScope)parent;
			currScope.addSubLocalScope(localScope);
		} else if (parent.getScopeKind() != NameScopeKind.NSK_METHOD && parent.getScopeKind() != NameScopeKind.NSK_DETAILED_TYPE) {
			throw new AssertionError("The parent scope of a local scope must be a local scope, a method, or a type!");
		}
		return localScope;
	}
	
	/**
	 * Define a parameter in a SingleVariableDeclaration to the scope given by the parameter currentScope
	 */
	VariableDefinition defineParameber(CompilationUnitRecorder currentUnitFile, SingleVariableDeclaration node, NameScope currentScope) {
		Type type = node.getType();
		typeVisitor.reset(currentUnitFile, currentScope);
		type.accept(typeVisitor);
		TypeReference typeRef = typeVisitor.getResult();
		// Set the correct dimension for the variable 
		int dimension = typeRef.getDimension() + node.getExtraDimensions();
		typeRef.setDimension(dimension);

		// Add the reference to the reference list in the current scope, which include the parameter
		currentScope.addReference(typeRef);
		
		// Define the variable to the current scope
		String varName = node.getName().getFullyQualifiedName();
		SourceCodeLocation location = SourceCodeLocation.getStartLocation(node, currentUnitFile.root, currentUnitFile.unitName);
		VariableDefinition variableDef = new VariableDefinition(varName, varName, location, currentScope);
		variableDef.setDefinitionKind(NameDefinitionKind.NDK_PARAMETER);
		variableDef.setType(typeRef);
		currentScope.define(variableDef);
		return variableDef;
	}

	
	/**
	 * Define a field in a VariableDeclaration to the scope given by the parameter currentScope
	 * The caller must to provide the type reference for the variable, since the the node may be a VariableDeclarationFragment
	 * Because the dimension of the node may be different from the other variables declared in the same variableDeclaration,
	 * we should copy the type reference for the variable definition of the node.
	 */
	FieldDefinition defineField(CompilationUnitRecorder currentUnitFile, String qualifier, VariableDeclaration node, TypeReference varTypeRef, NameScope currentScope, int modifierFlag) {
		// And because the dimension of the node may be different from the other variables declared in the same variableDeclaration,
		// we should copy the type reference for the variable definition of the node.
		TypeReference typeRef = null;
		if (varTypeRef.isQualifiedType()) typeRef = new QualifiedTypeReference((QualifiedTypeReference)varTypeRef);
		else if (varTypeRef.isParameterizedType()) typeRef = new ParameterizedTypeReference((ParameterizedTypeReference)varTypeRef);
		else typeRef = new TypeReference(varTypeRef);

		// Set the correct dimension for the variable 
		int dimension = varTypeRef.getDimension() + node.getExtraDimensions();
		typeRef.setDimension(dimension);
		
		// Add the reference to the reference list in the current scope
		currentScope.addReference(typeRef);

		// Define the variable to the current scope
		String varName = node.getName().getFullyQualifiedName();
		String fullQualifiedName = (qualifier == null) ? varName : qualifier + NameReferenceLabel.NAME_QUALIFIER + varName;
		SourceCodeLocation location = SourceCodeLocation.getStartLocation(node, currentUnitFile.root, currentUnitFile.unitName);
		FieldDefinition fieldDef = new FieldDefinition(varName, fullQualifiedName, location, currentScope);
		fieldDef.setType(typeRef);
		fieldDef.setModifierFlag(modifierFlag);
		currentScope.define(fieldDef);
		return fieldDef;
	}
	
	
	/**
	 * Define a variable in a VariableDeclaration to the scope given by the parameter currentScope
	 * The caller must to provide the type reference for the variable, since the the node may be a VariableDeclarationFragment
	 * Because the dimension of the node may be different from the other variables declared in the same variableDeclaration,
	 * we should copy the type reference for the variable definition of the node.
	 */
	VariableDefinition defineVariable(CompilationUnitRecorder currentUnitFile, VariableDeclaration node, TypeReference varTypeRef, NameScope currentScope) {
		// And because the dimension of the node may be different from the other variables declared in the same variableDeclaration,
		// we should copy the type reference for the variable definition of the node.
		TypeReference typeRef = null;
		if (varTypeRef.isQualifiedType()) typeRef = new QualifiedTypeReference((QualifiedTypeReference)varTypeRef);
		else if (varTypeRef.isParameterizedType()) typeRef = new ParameterizedTypeReference((ParameterizedTypeReference)varTypeRef);
		else typeRef = new TypeReference(varTypeRef);
		
		// Set the correct dimension for the variable 
		int dimension = varTypeRef.getDimension() + node.getExtraDimensions();
		typeRef.setDimension(dimension);
		
		// Add the reference to the reference list in the current scope
		currentScope.addReference(typeRef);

		// Define the variable to the current scope
		String varName = node.getName().getFullyQualifiedName();
		SourceCodeLocation location = SourceCodeLocation.getStartLocation(node, currentUnitFile.root, currentUnitFile.unitName);
		VariableDefinition variableDef = new VariableDefinition(varName, varName, location, currentScope);
		variableDef.setType(typeRef);
		currentScope.define(variableDef);
		return variableDef;
	}
}
