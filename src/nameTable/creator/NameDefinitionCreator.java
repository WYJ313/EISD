package nameTable.creator;

import java.util.List;

import nameTable.nameDefinition.AutoGeneratedConstructor;
import nameTable.nameDefinition.DetailedTypeDefinition;
import nameTable.nameDefinition.EnumConstantDefinition;
import nameTable.nameDefinition.EnumTypeDefinition;
import nameTable.nameDefinition.FieldDefinition;
import nameTable.nameDefinition.MethodDefinition;
import nameTable.nameDefinition.NameDefinitionKind;
import nameTable.nameDefinition.TypeParameterDefinition;
import nameTable.nameDefinition.VariableDefinition;
import nameTable.nameReference.NameReference;
import nameTable.nameReference.NameReferenceLabel;
import nameTable.nameReference.ParameterizedTypeReference;
import nameTable.nameReference.QualifiedTypeReference;
import nameTable.nameReference.TypeReference;
import nameTable.nameScope.LocalScope;
import nameTable.nameScope.NameScope;

import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.AbstractTypeDeclaration;
import org.eclipse.jdt.core.dom.Block;
import org.eclipse.jdt.core.dom.BodyDeclaration;
import org.eclipse.jdt.core.dom.EnumConstantDeclaration;
import org.eclipse.jdt.core.dom.EnumDeclaration;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.FieldDeclaration;
import org.eclipse.jdt.core.dom.Initializer;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
import org.eclipse.jdt.core.dom.Statement;
import org.eclipse.jdt.core.dom.Type;
import org.eclipse.jdt.core.dom.TypeDeclaration;
import org.eclipse.jdt.core.dom.TypeParameter;
import org.eclipse.jdt.core.dom.VariableDeclaration;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;

import sourceCodeAST.CompilationUnitRecorder;
import sourceCodeAST.SourceCodeFileSet;
import sourceCodeAST.SourceCodeLocation;

/**
 * The class creates all name definitions for all Java source code files under a given path. Moreover, 
 * some name references related to name definitions will be created at the same time, including super type
 * references in type definitions, return type references in method definitions, type references in 
 * parameters of methods, type references in variable definitions and field definitions.
 * 
 * @author Zhou Xiaocong
 * @since 2013-4-12
 * @version 1.0
 * 
 * @update 2013-9-28
 * Add a constructor (i.e. NameDefinitionCreator(SourceCodeParser)) to use the parser provide by the client
 * 
 * @update 2016/11/11
 * 		Refactor the class according to the design document
 */
public class NameDefinitionCreator extends NameTableCreator {

	public NameDefinitionCreator(SourceCodeFileSet parser) {
		super(parser);
	}
	
	/**
	 * Scan a type declaration node to create name definitions and references
     * TypeDeclaration:
     *  [ Javadoc ] { Modifier } class Identifier
     *                   [ extends Type]
     *                   [ implements Type { , Type } ]
     *                   { { BodyDeclaration | ; } }
     *  BodyDeclaration: FieldDelcaration MethodDeclaration TypeDeclaration           
	 */
	@SuppressWarnings("unchecked")
	void scan(CompilationUnitRecorder currentUnitFile, String qualifier, TypeDeclaration node, NameScope currentScope) {
		// Create a type definition for the node
		String name = node.getName().getFullyQualifiedName();
		String fullQualifiedName = (qualifier == null) ? name : qualifier + NameReferenceLabel.NAME_QUALIFIER + name;
		SourceCodeLocation location = SourceCodeLocation.getStartLocation(node, currentUnitFile.root, currentUnitFile.unitName);
		SourceCodeLocation endLocation = SourceCodeLocation.getEndLocation(node, currentUnitFile.root, currentUnitFile.unitName);
		DetailedTypeDefinition typeDef = new DetailedTypeDefinition(name, fullQualifiedName, location, currentScope, endLocation);
		typeDef.setInterface(node.isInterface());
		typeDef.setPackageMember(node.isPackageMemberTypeDeclaration());
		typeDef.setModifierFlag(node.getModifiers());
		currentScope.define(typeDef);
		
		// Create type reference for the super class
		if (node.getSuperclassType() != null) {
			Type superClassType = node.getSuperclassType();
			typeVisitor.reset(currentUnitFile, currentScope);
			superClassType.accept(typeVisitor);
			TypeReference superClassRef = typeVisitor.getResult();
			typeDef.addSuperType(superClassRef);
		}
		// Create type reference for the super interfaces
		List<Type> superInterfaces = node.superInterfaceTypes();
		for (Type superInterface : superInterfaces) {
			typeVisitor.reset(currentUnitFile, currentScope);
			superInterface.accept(typeVisitor);
			TypeReference superInterfaceRef = typeVisitor.getResult();
			typeDef.addSuperType(superInterfaceRef);
		}
		
		// Process the type parameter definition of the node
		List<TypeParameter> typeParameterList = node.typeParameters();
		for (TypeParameter typeParameter : typeParameterList) {
			String typeParaName = typeParameter.getName().getFullyQualifiedName();
			SourceCodeLocation typeParaLocation = SourceCodeLocation.getStartLocation(typeParameter, currentUnitFile.root, currentUnitFile.unitName);
			TypeParameterDefinition typeParaDef = new TypeParameterDefinition(typeParaName, typeParaName, typeParaLocation, typeDef);
			typeDef.define(typeParaDef);
		}
		
		// Process the initializers in the node
		List<BodyDeclaration> bodyList = node.bodyDeclarations();
		for (BodyDeclaration bodyDecl : bodyList) {
			int nodeType = bodyDecl.getNodeType();
			if (nodeType == ASTNode.INITIALIZER) {
				scan(currentUnitFile, (Initializer)bodyDecl, typeDef);
			}
		}
	
		// Process the field declarations in the node
		FieldDeclaration[] fields = node.getFields();
		for (int index = 0; index < fields.length; index++) scan(currentUnitFile, fullQualifiedName, fields[index], typeDef);
		
		// Process the method declarations in the node
		MethodDeclaration[] methods = node.getMethods();
		for (int index = 0; index < methods.length; index++) scan(currentUnitFile, fullQualifiedName, methods[index], typeDef);
		
		// Automatically generated default constructor if this class has not any constructor
		boolean hasConstructor = false;
		List<MethodDefinition> methodList = typeDef.getMethodList();
		if (methodList != null) {
			for (MethodDefinition method : methodList) {
				if (method.isConstructor()) {
					hasConstructor = true;
					break;
				}
			}
		}
		if (!hasConstructor) {
			MethodDefinition defaultConstructor = new AutoGeneratedConstructor(name, fullQualifiedName, location, typeDef, location);
			typeDef.define(defaultConstructor);
		}
		
		// Process the type declarations in the node
		AbstractTypeDeclaration[] typeMembers = node.getTypes(); 
		for (int index = 0; index < typeMembers.length; index++) {
			AbstractTypeDeclaration type = typeMembers[index];
			if (type.getNodeType() == ASTNode.TYPE_DECLARATION) {
				scan(currentUnitFile, fullQualifiedName, (TypeDeclaration)type, typeDef);
			} else if (type.getNodeType() == ASTNode.ENUM_DECLARATION) {
				scan(currentUnitFile, fullQualifiedName, (EnumDeclaration)type, typeDef);
			}
		}
	}

	/**
	 * Scan a enum declaration node to create name definitions and references
	 * EnumDeclaration:
     * 	[ Javadoc ] { ExtendedModifier } enum Identifier
     *	    [ implements Type { , Type } ]
     *	    {
     *	    	[ EnumConstantDeclaration { , EnumConstantDeclaration } ] [ , ]
     *	    	[ ; { ClassBodyDeclaration | ; } ]
     *	    }
	 */
	@SuppressWarnings("unchecked")
	void scan(CompilationUnitRecorder currentUnitFile, String qualifier, EnumDeclaration node, NameScope currentScope) {
		// Create a type definition for the node
		String name = node.getName().getFullyQualifiedName();
		String fullQualifiedName = (qualifier == null) ? name : qualifier + NameReferenceLabel.NAME_QUALIFIER + name;
		SourceCodeLocation location = SourceCodeLocation.getStartLocation(node, currentUnitFile.root, currentUnitFile.unitName);
		SourceCodeLocation endLocation = SourceCodeLocation.getEndLocation(node, currentUnitFile.root, currentUnitFile.unitName);
		EnumTypeDefinition typeDef = new EnumTypeDefinition(name, fullQualifiedName, location, currentScope, endLocation);
		typeDef.setPackageMember(node.isPackageMemberTypeDeclaration());
		typeDef.setModifierFlag(node.getModifiers());
		currentScope.define(typeDef);
		
		// Create type reference for the super interfaces
		List<Type> superInterfaces = node.superInterfaceTypes();
		for (Type superInterface : superInterfaces) {
			typeVisitor.reset(currentUnitFile, currentScope);
			superInterface.accept(typeVisitor);
			TypeReference superInterfaceRef = typeVisitor.getResult();
			typeDef.addSuperType(superInterfaceRef);
			// Add to the reference list in the current scope, which include the type definition
		}
		
		// Process the constant declarations in the node. We regard the enum constant as method 
		List<EnumConstantDeclaration> constants = node.enumConstants();
		for (EnumConstantDeclaration constant : constants) {
			scan(currentUnitFile, fullQualifiedName, constant, typeDef);
		}
	}

	/**
	 * Scan a field declaration node to create name definitions and references
	 * FieldDelcaration: [Javadoc] { ExtendedModifier } Type VariableDeclarationFragment
     *                       { , VariableDeclarationFragment } ;
	 */
	@SuppressWarnings("unchecked")
	void scan(CompilationUnitRecorder currentUnitFile, String qualifier, FieldDeclaration node, NameScope currentScope) {
		// Get the type reference for the variable declaration
		Type type = node.getType();
		typeVisitor.reset(currentUnitFile, currentScope);
		type.accept(typeVisitor);
		TypeReference typeRef = typeVisitor.getResult();
		// Add to the reference list in the currentScope, which include the field
		
		int modifierFlag = node.getModifiers();
		
		// Visit the variable list defined in the node
		List<VariableDeclarationFragment> fragments = node.fragments();
		for (VariableDeclarationFragment varNode : fragments) {
			// Define the variable to the current scope
			FieldDefinition field = defineField(currentUnitFile, qualifier, varNode, typeRef, currentScope, modifierFlag);
			
			// Visit the initializer in the variable declaration
			Expression initializer = varNode.getInitializer();
			if (initializer != null) {
				expressionVisitor.reset(currentUnitFile, currentScope);
				initializer.accept(expressionVisitor);
				NameReference initExpRef = expressionVisitor.getResult();
				currentScope.addReference(initExpRef);
				field.setInitializer(initExpRef);
			}
		}
	}

	/**
	 * Scan a method declaration node to create name definitions and references
     *  [ Javadoc ] { ExtendedModifier }
     *              [ < TypeParameter { , TypeParameter } > ]
     *    ( Type | void ) Identifier (
     *    [ FormalParameter
     *                 { , FormalParameter } ] ) {[ ] }
     *   [ throws TypeName { , TypeName } ] ( Block | ; )
	 */
	@SuppressWarnings("unchecked")
	void scan(CompilationUnitRecorder currentUnitFile, String qualifier, MethodDeclaration node, NameScope currentScope) {
		
		// Create method definition for the node
		String methodName = node.getName().getFullyQualifiedName();
		String fullQualifiedName = (qualifier == null) ? methodName : qualifier + NameReferenceLabel.NAME_QUALIFIER + methodName;
		SourceCodeLocation location = SourceCodeLocation.getStartLocation(node, currentUnitFile.root, currentUnitFile.unitName);
		SourceCodeLocation endLocation = SourceCodeLocation.getEndLocation(node, currentUnitFile.root, currentUnitFile.unitName);
		MethodDefinition methodDef = new MethodDefinition(methodName, fullQualifiedName, location, currentScope, endLocation);

		// Create type reference for the return type
		Type returnType = node.getReturnType2();
		TypeReference returnTypeRef = null;
		if (returnType != null) {
			typeVisitor.reset(currentUnitFile, methodDef);
			returnType.accept(typeVisitor);
			returnTypeRef = typeVisitor.getResult();
			int dimension = returnTypeRef.getDimension() + node.getExtraDimensions();
			returnTypeRef.setDimension(dimension);
		} // else is a constructor 
		methodDef.setReturnType(returnTypeRef);
		methodDef.setModifierFlag(node.getModifiers());
		methodDef.setConstructor(node.isConstructor());
		currentScope.define(methodDef);

		// Process the type parameter definition of the node
		List<TypeParameter> typeParameterList = node.typeParameters();
		for (TypeParameter typeParameter : typeParameterList) {
			String typeParaName = typeParameter.getName().getFullyQualifiedName();
			SourceCodeLocation typeParaLocation = SourceCodeLocation.getStartLocation(typeParameter, currentUnitFile.root, currentUnitFile.unitName);
			TypeParameterDefinition typeParaDef = new TypeParameterDefinition(typeParaName, typeParaName, typeParaLocation, methodDef);
			methodDef.define(typeParaDef);
		}
		
		// Create parameter definition for the node
		List<SingleVariableDeclaration> parameters = node.parameters();
		for (SingleVariableDeclaration parameter : parameters) {
			defineParameber(currentUnitFile, parameter, methodDef);
		}
		
		// Create type reference for throws type in the node
		List<Type> throwTypes = node.thrownExceptionTypes();
		for (Type throwType : throwTypes) {
			typeVisitor.reset(currentUnitFile, currentScope);
			throwType.accept(typeVisitor);
			TypeReference throwTypeRef = typeVisitor.getResult();
			methodDef.addThrowType(throwTypeRef);
		}
		
		// Scan the body of the method
		Block body = node.getBody();
		if (body != null) {
			SourceCodeLocation start = SourceCodeLocation.getStartLocation(body, currentUnitFile.root, currentUnitFile.unitName);
			SourceCodeLocation end = SourceCodeLocation.getEndLocation(body, currentUnitFile.root, currentUnitFile.unitName);
			LocalScope localScope = createLocalScope(start, end, methodDef);
			methodDef.setBodyScope(localScope);
			// We can not reuse the block visitor for all methods, because when the method defines 
			// local types, and there are methods in the local types, we can not reuse the scope stack in 
			// the same block visitor! 
			BlockDefinitionASTVisitor blockVisitor = new BlockDefinitionASTVisitor(this, currentUnitFile, localScope);
			// Then visit all children of the block
			List<Statement> statementList = body.statements();
			for (Statement statement : statementList) statement.accept(blockVisitor);
		}
	}
	
	/**
	 * Scan an enum constant declaration node to create name definitions 
	 */
 	@SuppressWarnings("unchecked")
	void scan(CompilationUnitRecorder unitFile, String qualifier, EnumConstantDeclaration node, NameScope currentScope) {
		String name = node.getName().getFullyQualifiedName();
		String fullQualifiedName = (qualifier == null) ? name : qualifier + NameReferenceLabel.NAME_QUALIFIER + name;
		SourceCodeLocation location = SourceCodeLocation.getStartLocation(node, unitFile.root, unitFile.unitName);
		
		EnumConstantDefinition constDef = new EnumConstantDefinition(name, fullQualifiedName, location, currentScope);
		currentScope.define(constDef);
		
		// We need references of an enum constant, so we must use ExpressionASTVisitor rather than ExrpessionDefinitionVisitor.
		// The latter can not actually create references!
		ExpressionASTVisitor visitor = new ExpressionASTVisitor(this, unitFile, currentScope);
		List<Expression> arguments = node.arguments();
		for (Expression argument : arguments) {
			argument.accept(visitor);
			NameReference argRef = visitor.getResult();
			if (argRef != null) constDef.addArgument(argRef);
		}
	}
	
	/**
	 * Define a parameter in a SingleVariableDeclaration to the scope given by the parameter currentScope
	 */
	VariableDefinition defineParameber(CompilationUnitRecorder currentUnitFile, SingleVariableDeclaration node, NameScope currentScope) {
		Type type = node.getType();
		typeVisitor.reset(currentUnitFile, currentScope);
		type.accept(typeVisitor);
		TypeReference typeRef = typeVisitor.getResult();
		// Set the correct dimension for the variable 
		int dimension = typeRef.getDimension() + node.getExtraDimensions();
		typeRef.setDimension(dimension);

		// Define the variable to the current scope
		String varName = node.getName().getFullyQualifiedName();
		SourceCodeLocation location = SourceCodeLocation.getStartLocation(node, currentUnitFile.root, currentUnitFile.unitName);
		VariableDefinition variableDef = new VariableDefinition(varName, varName, location, currentScope);
		variableDef.setDefinitionKind(NameDefinitionKind.NDK_PARAMETER);
		variableDef.setType(typeRef);
		currentScope.define(variableDef);
		return variableDef;
	}

	/**
	 * Define a field in a VariableDeclaration to the scope given by the parameter currentScope
	 * The caller must to provide the type reference for the variable, since the the node may be a VariableDeclarationFragment
	 * Because the dimension of the node may be different from the other variables declared in the same variableDeclaration,
	 * we should copy the type reference for the variable definition of the node.
	 */
	FieldDefinition defineField(CompilationUnitRecorder currentUnitFile, String qualifier, VariableDeclaration node, TypeReference varTypeRef, NameScope currentScope, int modifierFlag) {
		// And because the dimension of the node may be different from the other variables declared in the same variableDeclaration,
		// we should copy the type reference for the variable definition of the node.
		TypeReference typeRef = null;
		if (varTypeRef.isQualifiedType()) typeRef = new QualifiedTypeReference((QualifiedTypeReference)varTypeRef);
		else if (varTypeRef.isParameterizedType()) typeRef = new ParameterizedTypeReference((ParameterizedTypeReference)varTypeRef);
		else typeRef = new TypeReference(varTypeRef);

		// Set the correct dimension for the variable 
		int dimension = varTypeRef.getDimension() + node.getExtraDimensions();
		typeRef.setDimension(dimension);
		
		// Define the variable to the current scope
		String varName = node.getName().getFullyQualifiedName();
		String fullQualifiedName = (qualifier == null) ? varName : qualifier + NameReferenceLabel.NAME_QUALIFIER + varName;
		SourceCodeLocation location = SourceCodeLocation.getStartLocation(node, currentUnitFile.root, currentUnitFile.unitName);
		FieldDefinition fieldDef = new FieldDefinition(varName, fullQualifiedName, location, currentScope);
		fieldDef.setType(typeRef);
		fieldDef.setModifierFlag(modifierFlag);
		currentScope.define(fieldDef);
		return fieldDef;
	}
	
	/**
	 * Define a variable in a VariableDeclaration to the scope given by the parameter currentScope
	 * The caller must to provide the type reference for the variable, since the the node may be a VariableDeclarationFragment
	 * Because the dimension of the node may be different from the other variables declared in the same variableDeclaration,
	 * we should copy the type reference for the variable definition of the node.
	 */
	VariableDefinition defineVariable(CompilationUnitRecorder currentUnitFile, VariableDeclaration node, TypeReference varTypeRef, NameScope currentScope) {
		// And because the dimension of the node may be different from the other variables declared in the same variableDeclaration,
		// we should copy the type reference for the variable definition of the node.
		TypeReference typeRef = null;
		if (varTypeRef.isQualifiedType()) typeRef = new QualifiedTypeReference((QualifiedTypeReference)varTypeRef);
		else if (varTypeRef.isParameterizedType()) typeRef = new ParameterizedTypeReference((ParameterizedTypeReference)varTypeRef);
		else typeRef = new TypeReference(varTypeRef);
		
		// Set the correct dimension for the variable 
		int dimension = varTypeRef.getDimension() + node.getExtraDimensions();
		typeRef.setDimension(dimension);
		
		// Define the variable to the current scope
		String varName = node.getName().getFullyQualifiedName();
		SourceCodeLocation location = SourceCodeLocation.getStartLocation(node, currentUnitFile.root, currentUnitFile.unitName);
		VariableDefinition variableDef = new VariableDefinition(varName, varName, location, currentScope);
		variableDef.setType(typeRef);
		currentScope.define(variableDef);
		return variableDef;
	}
	
}
