package analyzer.nullCheck;

import java.io.File;
import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.util.List;

import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CompilationUnit;

import graph.basic.GraphNode;
import graph.cfg.ControlFlowGraph;
import graph.cfg.ExecutionPoint;
import graph.cfg.analyzer.ReachNameDefinition;
import graph.cfg.analyzer.ReachNameAnalyzer;
import graph.cfg.creator.CFGCreator;
import nameTable.NameTableManager;
import nameTable.creator.NameReferenceCreator;
import nameTable.filter.NameDefinitionKindFilter;
import nameTable.nameDefinition.DetailedTypeDefinition;
import nameTable.nameDefinition.MethodDefinition;
import nameTable.nameDefinition.NameDefinition;
import nameTable.nameDefinition.NameDefinitionKind;
import nameTable.nameDefinition.TypeDefinition;
import nameTable.nameReference.NameReference;
import nameTable.nameReference.NameReferenceKind;
import nameTable.nameReference.referenceGroup.NameReferenceGroup;
import nameTable.nameReference.referenceGroup.NameReferenceGroupKind;
import nameTable.nameScope.CompilationUnitScope;
import nameTable.visitor.NameDefinitionVisitor;
import sourceCodeAST.CompilationUnitRecorder;
import sourceCodeAST.SourceCodeFileSet;
import sourceCodeAST.SourceCodeLocation;
import util.Debug;

/**
 * @author Zhou Xiaocong
 * @since 2017Äê9ÔÂ10ÈÕ
 * @version 1.0
 *
 */
public class MethodNullCheckCollector {

	
	public static void main(String[] args) {
		String rootPath = "C:\\";

		
		String[] paths = {"C:\\QualitasPacking\\recent\\eclipse_SDK\\eclipse_SDK-4.3\\", "C:\\QualitasPacking\\recent\\jfreechart\\jfreechart-1.0.13\\", 
							rootPath + "ZxcWork\\JAnalyzer\\src\\", rootPath + "ZxcTools\\EclipseSource\\org\\", rootPath + "ZxcTemp\\JAnalyzer\\src\\",
							rootPath + "ZxcWork\\ToolKit\\src\\sourceCodeAsTestCase\\TestGenericType.java", rootPath + "ZxcDeveloping\\OOPAndJavaExamples\\automata\\src\\", 
							rootPath + "ZxcProject\\AspectViz\\ZxcWork\\SortAnimator4\\", rootPath + "ZxcTools\\JDKSource\\", 
							rootPath + "ZxcCourse\\JavaProgramming\\JHotDraw5.2\\sources\\", rootPath + "ZxcWork\\FaultLocalization\\src\\", 
							rootPath + "ZxcTools\\ArgoUml\\", rootPath + "ZxcTools\\jEdit_5_1_0\\", 
							rootPath + "ZxcTools\\lucene_2_0_0\\", rootPath + "ZxcTools\\struts_2_0_1\\",
							rootPath + "ZxcTools\\apache_ant_1_9_3\\src\\", rootPath + "ZxcTools\\apache_ant_1_9_3\\src\\main\\org\\apache\\tools\\ant\\",
		};
		
		String path = paths[2];
		String result = rootPath + "ZxcWork\\ProgramAnalysis\\data\\result.txt";

		PrintWriter writer = new PrintWriter(System.out);
		PrintWriter output = new PrintWriter(System.out);
		
		try {
			writer = new PrintWriter(new FileOutputStream(new File(result)));
		} catch (Exception exc) {
			exc.printStackTrace();
			writer.close();
			return;
		}
		
		try {
			String info = rootPath + "ZxcWork\\ProgramAnalysis\\data\\debug.txt";
			output = new PrintWriter(new FileOutputStream(new File(info)));
			Debug.setWriter(output);
			Debug.setScreenOn();
		} catch (Exception exc) {
			exc.printStackTrace();
			writer.close();
			output.close();
			return;
		}
		
		try {
			Debug.setStart("Begin collection....");
			collectAllMethodsNullCheckByScanningMethod(path, writer);
			Debug.time("After collection...");
		} catch (Exception exc) {
			exc.printStackTrace();
		}

		writer.close();
		output.close();

	}

	public static void collectAllMethodsNullCheckByScanningMethod(String path, PrintWriter writer) {
		NameTableManager manager = NameTableManager.createNameTableManager(path);

		NameDefinitionVisitor visitor = new NameDefinitionVisitor(new NameDefinitionKindFilter(NameDefinitionKind.NDK_METHOD));
		manager.accept(visitor);
		List<NameDefinition> methodList = visitor.getResult();
		
		SourceCodeFileSet sourceCodeFileSet = manager.getSouceCodeFileSet();
		
		int counter = 0;
		String message = "No\tUnitFile\tClass\tMethod\tLocation\tCheckedReference\tBindDefinition\tAssigned\tIsField\tFirstAssignedValue\tOtherAssignedValue";
		writer.println(message);
		for (NameDefinition nameDefinition : methodList) {
			MethodDefinition method = (MethodDefinition)nameDefinition;
			if (method.isAutoGenerated()) continue; 
			TypeDefinition enclosingType = method.getEnclosingType();
			DetailedTypeDefinition type = (DetailedTypeDefinition)enclosingType; 
			if (type.isAnonymous()) continue;
			
			SourceCodeLocation location = method.getLocation();
			String unitFileName = location.getFileUnitName();
			String className = type.getSimpleName();
			String methodName = method.getSimpleName() + "()";

			Debug.println("Method: " + method.getUniqueId());

			ControlFlowGraph currentCFG = createCFGWithNullCheckedReferenceInCFGNode(manager, method);
			if (currentCFG == null) continue;
			
			List<GraphNode> nodeList = currentCFG.getAllNodes();
			for (GraphNode graphNode : nodeList) {
				if (!(graphNode instanceof ExecutionPoint)) continue;

				ExecutionPoint node = (ExecutionPoint)graphNode;
				if (!node.isPredicate()) continue;
				NullCheckReferenceRecorder recorder = (NullCheckReferenceRecorder)node.getFlowInfoRecorder();
				
				List<NameReference> checkedReferenceList = recorder.getCheckedReferneceList();
				List<ReachNameDefinition> definedNameList = recorder.getReachNameList();
				
				for (NameReference checkedReference : checkedReferenceList) {
					counter++;
					SourceCodeLocation checkLocation = checkedReference.getLocation();
					
					String locationString = "[" + checkLocation.toString() + "]";
					String referenceString = checkedReference.toSimpleString();
					String definitionString = "~~";
					String firstValueString = "~~";
					String otherValueString = "~~";
					boolean assigned = false;
					boolean isField = false;
					
					NameDefinition checkedDefinition = extractLeftValueInReference(checkedReference);
					if (checkedDefinition != null) {
						definitionString = checkedDefinition.getUniqueId();
						isField = checkedDefinition.isFieldDefinition();
						
						for (ReachNameDefinition definedName : definedNameList) {
							if (definedName.getName() == checkedDefinition) {
								assigned = true;
								NameReference value = definedName.getValue();
								if (value != null) {
									if (firstValueString.equals("~~")) {
										firstValueString = "[" + value.getLocation() + "]" + value.toSimpleString();
									} else if (otherValueString.equals("~~")) {
										otherValueString = "[" + value.getLocation() + "]" + value.toSimpleString();
									} else {
										otherValueString = otherValueString + ";~" + "[" + value.getLocation() + "]" + value.toSimpleString();
									}
								}
							}
						}
					}
					
					message = counter + "\t" + unitFileName + "\t" + className + "\t" + methodName + "\t" + locationString + "\t" + referenceString + "\t" + definitionString + "\t" + assigned + "\t" + isField + "\t" + firstValueString + "\t" + otherValueString;
					writer.println(message);
				}
			}
			
			sourceCodeFileSet.releaseAST(unitFileName);
			sourceCodeFileSet.releaseFileContent(unitFileName);
		}
	}
	
	public static ControlFlowGraph createCFGWithNullCheckedReferenceInCFGNode(NameTableManager nameTable, MethodDefinition method) {
		CompilationUnitScope unitScope = nameTable.getEnclosingCompilationUnitScope(method);
		if (unitScope == null) return null;
		String sourceFileName = unitScope.getUnitName();
		CompilationUnit astRoot = nameTable.getSouceCodeFileSet().findSourceCodeFileASTRootByFileUnitName(sourceFileName);
		if (astRoot == null) return null;
		CompilationUnitRecorder unitRecorder = new CompilationUnitRecorder(sourceFileName, astRoot);
		
		// Create a ControFlowGraph object
		ControlFlowGraph currentCFG = CFGCreator.create(nameTable, method);
		if (currentCFG == null) return null;
		
		setNullCheckReferenceRecorder(currentCFG);
		ReachNameAnalyzer.reachNameAnalysis(nameTable, unitRecorder, method, currentCFG);
		NullCheckReferenceAnalysis(nameTable, unitRecorder, method, currentCFG);
		return currentCFG;
	}
	
	static void setNullCheckReferenceRecorder(ControlFlowGraph currentCFG) {
		List<GraphNode> nodeList = currentCFG.getAllNodes();
		for (GraphNode graphNode : nodeList) {
			if (graphNode instanceof ExecutionPoint) {
				ExecutionPoint node = (ExecutionPoint)graphNode;
				NullCheckReferenceRecorder recorder = new NullCheckReferenceRecorder();
				node.setFlowInfoRecorder(recorder);
			}
		}
	}
	
	static void NullCheckReferenceAnalysis(NameTableManager manager, CompilationUnitRecorder unitRecorder, MethodDefinition method, ControlFlowGraph currentCFG) {
		NameReferenceCreator referenceCreator = new NameReferenceCreator(manager, true);
		
		List<GraphNode> nodeList = currentCFG.getAllNodes();
		for (GraphNode graphNode : nodeList) {
			if (!(graphNode instanceof ExecutionPoint)) continue;

			ExecutionPoint node = (ExecutionPoint)graphNode;
			ASTNode astNode = node.getAstNode();
			if (astNode == null) continue;

			NullCheckReferenceRecorder recorder = (NullCheckReferenceRecorder)node.getFlowInfoRecorder();
			List<NameReference> referenceList = referenceCreator.createReferencesForASTNode(unitRecorder.unitName, astNode);
			recorder.setNodeReference(referenceList);

			if (!node.isPredicate()) continue;
			for (NameReference reference : referenceList) {
				reference.resolveBinding();
				extractCheckNullPredicatesInReference(recorder, reference);
			}
		}
	}
	
	static void extractCheckNullPredicatesInReference(NullCheckReferenceRecorder recorder, NameReference reference) {
		if (!reference.isGroupReference()) return;
		
		NameReferenceGroup group = (NameReferenceGroup)reference;
		List<NameReference> sublist = group.getSubReferenceList();
		if (group.getGroupKind() == NameReferenceGroupKind.NRGK_INFIX_EXPRESSION) {
			String operator = group.getOperator();
			if (operator.equals(NameReferenceGroup.OPERATOR_EQUALS) || operator.equals(NameReferenceGroup.OPERATOR_NOT_EQUALS)) {
//				System.out.println("Reference [" + reference.getLocation().getUniqueId() + "]" + reference.toSimpleString());
				NameReference firstOperand = sublist.get(0);
				NameReference secondOperand = sublist.get(1);
				
				NameReference checkReference = null;
				if (firstOperand.isNullReference()) {
					checkReference = secondOperand;
				} else if (secondOperand.isNullReference()) {
					checkReference = firstOperand;
				}
				if (checkReference != null) recorder.addCheckedReference(checkReference);
			}
		}
		if (sublist != null) {
			for (NameReference subreference : sublist) extractCheckNullPredicatesInReference(recorder, subreference);
		}
	}
	
	public static NameDefinition extractLeftValueInReference(NameReference reference) {
		if (!reference.isGroupReference()) return reference.getDefinition();
		NameReferenceGroup group = (NameReferenceGroup)reference;
		NameReferenceGroupKind groupKind = group.getGroupKind();
		List<NameReference> sublist = group.getSubReferenceList();
		
		if (groupKind == NameReferenceGroupKind.NRGK_ARRAY_ACCESS) {
			return sublist.get(0).getDefinition();
		} else if (groupKind == NameReferenceGroupKind.NRGK_FIELD_ACCESS) {
			return sublist.get(1).getDefinition();
		} else if (groupKind == NameReferenceGroupKind.NRGK_METHOD_INVOCATION ||
				groupKind == NameReferenceGroupKind.NRGK_SUPER_METHOD_INVOCATION) {
			for (NameReference subreference : sublist) {
				if (subreference.getReferenceKind() == NameReferenceKind.NRK_METHOD) {
					return subreference.getDefinition();
				}
			}
		} else if (groupKind == NameReferenceGroupKind.NRGK_SUPER_FIELD_ACCESS) {
			NameReference firstReference = sublist.get(0);
			if (firstReference.getReferenceKind() == NameReferenceKind.NRK_TYPE) 
				return sublist.get(1).getDefinition();
			else return firstReference.getDefinition();
		} else if (groupKind == NameReferenceGroupKind.NRGK_THIS_EXPRESSION) {
			return sublist.get(0).getDefinition();
		} else if (groupKind == NameReferenceGroupKind.NRGK_QUALIFIED_NAME) {
			return group.getDefinition();
		}
		return null;
	}
}

