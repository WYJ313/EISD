package analyzer.nullCheck;

import java.io.File;
import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.util.List;

import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CompilationUnit;

import graph.basic.GraphNode;
import graph.cfg.CFGNode;
import graph.cfg.CFGNodeType;
import graph.cfg.ControlFlowGraph;
import graph.cfg.ExecutionPoint;
import graph.cfg.ExecutionPointLabel;
import graph.cfg.ExecutionPointType;
import graph.cfg.creator.CFGCreator;
import nameTable.NameTableManager;
import nameTable.creator.NameReferenceCreator;
import nameTable.filter.NameDefinitionKindFilter;
import nameTable.nameDefinition.DetailedTypeDefinition;
import nameTable.nameDefinition.MethodDefinition;
import nameTable.nameDefinition.NameDefinition;
import nameTable.nameDefinition.NameDefinitionKind;
import nameTable.nameDefinition.TypeDefinition;
import nameTable.nameReference.NameReference;
import nameTable.nameReference.NameReferenceKind;
import nameTable.nameReference.NameReferenceLabel;
import nameTable.nameReference.TypeReference;
import nameTable.nameReference.referenceGroup.NameReferenceGroup;
import nameTable.nameScope.CompilationUnitScope;
import nameTable.visitor.NameDefinitionVisitor;
import sourceCodeAST.CompilationUnitRecorder;
import sourceCodeAST.SourceCodeLocation;
import util.Debug;

public class MethodReturnStatementCollector {

	public static void main(String[] args) {
		String rootPath = "C:\\";

		
		String[] paths = {"C:\\QualitasPacking\\recent\\eclipse_SDK\\eclipse_SDK-4.3\\", "C:\\QualitasPacking\\recent\\jfreechart\\jfreechart-1.0.13\\", 
							rootPath + "ZxcWork\\JAnalyzer\\src\\", rootPath + "ZxcTools\\EclipseSource\\org\\", rootPath + "ZxcTemp\\testcase\\",
							rootPath + "ZxcWork\\ToolKit\\src\\sourceCodeAsTestCase\\CNExample.java", rootPath + "ZxcDeveloping\\OOPAndJavaExamples\\automata\\src\\", 
							rootPath + "ZxcProject\\AspectViz\\ZxcWork\\SortAnimator4\\", rootPath + "ZxcTools\\JDKSource\\", 
							rootPath + "ZxcCourse\\JavaProgramming\\JHotDraw5.2\\sources\\", rootPath + "ZxcWork\\FaultLocalization\\src\\", 
							rootPath + "ZxcTools\\ArgoUml\\", rootPath + "ZxcTools\\jEdit_5_1_0\\", 
							rootPath + "ZxcTools\\lucene_2_0_0\\", rootPath + "ZxcTools\\struts_2_0_1\\",
							rootPath + "ZxcTools\\apache_ant_1_9_3\\src\\", rootPath + "ZxcTools\\apache_ant_1_9_3\\src\\main\\org\\apache\\tools\\ant\\",
		};
		
		String path = paths[2];
		String result = rootPath + "ZxcWork\\ProgramAnalysis\\data\\result.txt";

		PrintWriter writer = new PrintWriter(System.out);
		PrintWriter output = new PrintWriter(System.out);
		
		try {
			writer = new PrintWriter(new FileOutputStream(new File(result)));
		} catch (Exception exc) {
			exc.printStackTrace();
			return;
		}
		
		try {
			String info = rootPath + "ZxcWork\\ProgramAnalysis\\data\\debug.txt";
			output = new PrintWriter(new FileOutputStream(new File(info)));
			Debug.setWriter(output);
			Debug.setScreenOn();
		} catch (Exception exc) {
			exc.printStackTrace();
			writer.close();
			return;
		}
		
		try {
			Debug.setStart("Begin collection....");
			collectAllMethodsReturnStatements(path, writer);
			Debug.time("After collection...");
		} catch (Exception exc) {
			exc.printStackTrace();
		}

		writer.close();
		output.close();
	}

	public static void collectAllMethodsReturnStatements(String path, PrintWriter writer) {

		String[] fileNameArray = {"C:\\ZxcWork\\ToolKit\\data\\javalang.txt", "C:\\ZxcWork\\ToolKit\\data\\javautil.txt", "C:\\ZxcWork\\ToolKit\\data\\javaio.txt", }; 
		Debug.setStart("Begin creating system, path = " + path);
		NameTableManager manager = NameTableManager.createNameTableManager(path, new PrintWriter(System.out), fileNameArray);
		Debug.time("End creating.....");
		Debug.flush();
		
		NameDefinitionVisitor visitor = new NameDefinitionVisitor(new NameDefinitionKindFilter(NameDefinitionKind.NDK_METHOD));
		manager.accept(visitor);
		List<NameDefinition> methodList = visitor.getResult();
		NameReferenceCreator referenceCreator = new NameReferenceCreator(manager, true);
		
		String message = "No\tClass\tMethod\tRetExp\tRetExpKind\tRetExpBindDef\tRetExpLocation";
		int counter = 0;
		
		writer.println(message);
		for (NameDefinition nameDefinition : methodList) {
			MethodDefinition method = (MethodDefinition)nameDefinition;
			if (method.isAutoGenerated()) continue; 
			TypeDefinition enclosingType = method.getEnclosingType();
			DetailedTypeDefinition type = (DetailedTypeDefinition)enclosingType;
			if (type.isAnonymous()) continue;
			if (method.isConstructor()) continue;
			
			SourceCodeLocation location = method.getLocation();
			String unitFileName = location.getFileUnitName();
			String className = type.getSimpleName();
			String methodName = method.getSimpleName() + "()";
			String rowCol = "[" + location.getLineNumber() + "," + location.getColumn() + "]";
			TypeReference returnType = method.getReturnType(); 
			if (returnType == null) {
				throw new AssertionError("Non-constructor " + methodName + " at " + location.getUniqueId() + " has no return type reference!");
			}
			if (NameReferenceLabel.isPrimitiveTypeName(returnType.getName()) && !returnType.isArrayType()) continue;
			
			// Create a ControFlowGraph object
			ControlFlowGraph graph = CFGCreator.create(manager, method);
			if (graph == null) continue;
			List<GraphNode> nodeList = graph.getAllNodes();
			if (nodeList == null) continue;

			Debug.println("Collect method " + method.getFullQualifiedName());
			
			for (GraphNode node : nodeList) {
				CFGNode cfgNode = (CFGNode)node;
				if (cfgNode.getCFGNodeType() != CFGNodeType.N_EXECUTION_POINT) continue;
				ExecutionPoint exePoint = (ExecutionPoint)cfgNode;
				
				if (exePoint.getType() == ExecutionPointType.FLOW_CONTROLLER && exePoint.getLabel() == ExecutionPointLabel.RETURN_LABEL) {
					ASTNode astNode = exePoint.getAstNode();
					List<NameReference> referenceList = referenceCreator.createReferencesForASTNode(unitFileName, astNode);	
					if (referenceList != null) {
						if (referenceList.size() != 1) {
							throw new AssertionError("There are more than one expression in a return statement " + astNode);
						}
						NameReference reference = referenceList.get(0);
						String returnExpKind = "~~";
						NameReferenceKind kind = reference.getReferenceKind();
						if (kind != NameReferenceKind.NRK_GROUP) returnExpKind = kind.toString();
						else {
							NameReferenceGroup group = (NameReferenceGroup)reference;
							returnExpKind = group.getGroupKind().toString();
						}
						String returnExpDef = "~~";
						reference.resolveBinding();
						NameDefinition definition = reference.getDefinition();
						if (definition != null) returnExpDef = definition.getUniqueId();
						String returnExpLoc = reference.getLocation().getUniqueId();
						
						counter++;
						writer.println(counter + "\t" + className + "\t" + rowCol + methodName + "\t" + reference.toSimpleString() + "\t" + returnExpKind + "\t" + returnExpDef + "\t" + returnExpLoc);
					}
				}
			}
		}
		writer.flush();
	}
	
	public static CompilationUnitRecorder getEnclosingCompilationUnitRecorder(NameTableManager manager, NameDefinition definition) {
		CompilationUnitScope unitScope = manager.getEnclosingCompilationUnitScope(definition);
		if (unitScope == null) return null;
		String unitFileName = unitScope.getUnitName();
		CompilationUnit astRoot = manager.getSouceCodeFileSet().findSourceCodeFileASTRootByFileUnitName(unitFileName);
		if (astRoot == null) return null;
		CompilationUnitRecorder unitRecorder = new CompilationUnitRecorder(unitFileName, astRoot);
		
		return unitRecorder;
	}
}
